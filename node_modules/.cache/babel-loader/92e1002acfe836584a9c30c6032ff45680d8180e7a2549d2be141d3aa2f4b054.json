{"ast":null,"code":"class BFS {\n  constructor(nodes, start, goal, grid) {\n    this.nodes = nodes;\n    this.grid = grid;\n    this.start = start;\n    this.goal = goal;\n    console.log(grid);\n    console.log(nodes);\n    Object.keys(this.nodes).forEach(node => {\n      let currentNode = this.nodes[node];\n      currentNode.visited = false;\n      currentNode.parent = null;\n    });\n  }\n  search() {\n    let nodes = this.nodes;\n    let start = this.start;\n    let goal = this.goal;\n    let grid = this.grid;\n    let closedSet = [];\n    let queue = [start];\n    start.visited = true;\n    while (queue.length > 0) {\n      let node = queue.shift();\n      if (node.id === goal.id) {\n        let path = [];\n        let currentNode = node;\n        while (currentNode.parent) {\n          path.push(currentNode.id);\n          currentNode = currentNode.parent;\n        }\n\n        // console.log(path);\n        return {\n          path: path.reverse(),\n          visitedNodes: closedSet\n        };\n      }\n      const coordinates = node.id.split(\"-\");\n      const row = parseInt(coordinates[0]);\n      const col = parseInt(coordinates[1]);\n\n      // let nodeHTML = document.getElementById(node.id);\n      // console.log(nodeHTML);\n      if (node.id !== start.id) {\n        // nodeHTML.className = \"visited\";\n        // node.visited = true;\n        closedSet.push(node.id);\n      }\n\n      // let neighborNodes = [];\n      let neighborNode;\n      if (grid[row - 1] && grid[row - 1][col]) {\n        neighborNode = `${(row - 1).toString()}-${col.toString()}`;\n        if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n          queue.push(nodes[neighborNode]);\n          nodes[neighborNode].parent = node;\n          nodes[neighborNode].visited = true;\n        }\n      }\n      if (grid[0][col + 1] && grid[row][col + 1]) {\n        neighborNode = `${row.toString()}-${(col + 1).toString()}`;\n        if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n          queue.push(nodes[neighborNode]);\n          nodes[neighborNode].parent = node;\n          nodes[neighborNode].visited = true;\n        }\n      }\n      if (grid[row + 1] && grid[row + 1][col]) {\n        neighborNode = `${(row + 1).toString()}-${col.toString()}`;\n        if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n          queue.push(nodes[neighborNode]);\n          nodes[neighborNode].parent = node;\n          nodes[neighborNode].visited = true;\n        }\n      }\n      if (grid[0][col - 1] && grid[row][col - 1]) {\n        neighborNode = `${row.toString()}-${(col - 1).toString()}`;\n        if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n          queue.push(nodes[neighborNode]);\n          nodes[neighborNode].parent = node;\n          nodes[neighborNode].visited = true;\n        }\n      }\n    }\n  }\n}\nexport default BFS;","map":{"version":3,"names":["BFS","constructor","nodes","start","goal","grid","console","log","Object","keys","forEach","node","currentNode","visited","parent","search","closedSet","queue","length","shift","id","path","push","reverse","visitedNodes","coordinates","split","row","parseInt","col","neighborNode","toString","status"],"sources":["C:/Users/MSI/OneDrive/Desktop/Grid Visual/src/BFS.js"],"sourcesContent":["class BFS {\n  constructor(nodes, start, goal, grid) {\n    this.nodes = nodes;\n    this.grid = grid;\n    this.start = start;\n    this.goal = goal;\n    console.log(grid);\n    console.log(nodes);\n    Object.keys(this.nodes).forEach(node => {\n      let currentNode = this.nodes[node];\n      currentNode.visited = false;\n      currentNode.parent = null;\n    });\n  }\n\n  search() {\n    let nodes = this.nodes;\n    let start = this.start;\n    let goal = this.goal;\n    let grid = this.grid;\n    let closedSet = [];\n    \n\n    let queue = [start];\n    start.visited = true;\n\n    while (queue.length > 0) {\n        let node = queue.shift();\n\n      if (node.id === goal.id) {\n        let path = [];\n        let currentNode = node;\n\n        \n        while (currentNode.parent) {\n          path.push(currentNode.id);\n          currentNode = currentNode.parent;\n        }\n        \n        // console.log(path);\n        return { path: path.reverse(), visitedNodes: closedSet };\n      }\n      \n\n      const coordinates = node.id.split(\"-\");\n      const row = parseInt(coordinates[0]);\n      const col = parseInt(coordinates[1]);\n\n      // let nodeHTML = document.getElementById(node.id);\n      // console.log(nodeHTML);\n      if (node.id !== start.id) {\n        // nodeHTML.className = \"visited\";\n        // node.visited = true;\n        closedSet.push(node.id);\n      }\n\n      // let neighborNodes = [];\n      let neighborNode;\n      if (grid[row - 1] && grid[row - 1][col]) {\n        neighborNode = `${(row - 1).toString()}-${col.toString()}`;\n          if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n                queue.push(nodes[neighborNode]);\n                nodes[neighborNode].parent = node;\n                nodes[neighborNode].visited = true;\n          }\n      }\n      if (grid[0][col + 1] && grid[row][col + 1]) {\n        neighborNode = `${row.toString()}-${(col + 1).toString()}`;\n          if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n                queue.push(nodes[neighborNode]);\n                nodes[neighborNode].parent = node;\n                nodes[neighborNode].visited = true;\n          }\n      }\n      if (grid[row + 1] && grid[row + 1][col]) {\n        neighborNode = `${(row + 1).toString()}-${col.toString()}`;\n          if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n                queue.push(nodes[neighborNode]);\n                nodes[neighborNode].parent = node;\n                nodes[neighborNode].visited = true;\n          }\n      }\n      if (grid[0][col - 1] && grid[row][col - 1]) {\n        neighborNode = `${row.toString()}-${(col - 1).toString()}`;\n          if (nodes[neighborNode].status !== \"block\" && !nodes[neighborNode].visited) {\n                queue.push(nodes[neighborNode]);\n                nodes[neighborNode].parent = node;\n                nodes[neighborNode].visited = true;\n          }\n      }\n    }\n  }\n}\n\nexport default BFS;"],"mappings":"AAAA,MAAMA,GAAG,CAAC;EACRC,WAAW,CAACC,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACpC,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACG,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChBE,OAAO,CAACC,GAAG,CAACF,IAAI,CAAC;IACjBC,OAAO,CAACC,GAAG,CAACL,KAAK,CAAC;IAClBM,MAAM,CAACC,IAAI,CAAC,IAAI,CAACP,KAAK,CAAC,CAACQ,OAAO,CAACC,IAAI,IAAI;MACtC,IAAIC,WAAW,GAAG,IAAI,CAACV,KAAK,CAACS,IAAI,CAAC;MAClCC,WAAW,CAACC,OAAO,GAAG,KAAK;MAC3BD,WAAW,CAACE,MAAM,GAAG,IAAI;IAC3B,CAAC,CAAC;EACJ;EAEAC,MAAM,GAAG;IACP,IAAIb,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIC,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIC,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIC,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIW,SAAS,GAAG,EAAE;IAGlB,IAAIC,KAAK,GAAG,CAACd,KAAK,CAAC;IACnBA,KAAK,CAACU,OAAO,GAAG,IAAI;IAEpB,OAAOI,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;MACrB,IAAIP,IAAI,GAAGM,KAAK,CAACE,KAAK,EAAE;MAE1B,IAAIR,IAAI,CAACS,EAAE,KAAKhB,IAAI,CAACgB,EAAE,EAAE;QACvB,IAAIC,IAAI,GAAG,EAAE;QACb,IAAIT,WAAW,GAAGD,IAAI;QAGtB,OAAOC,WAAW,CAACE,MAAM,EAAE;UACzBO,IAAI,CAACC,IAAI,CAACV,WAAW,CAACQ,EAAE,CAAC;UACzBR,WAAW,GAAGA,WAAW,CAACE,MAAM;QAClC;;QAEA;QACA,OAAO;UAAEO,IAAI,EAAEA,IAAI,CAACE,OAAO,EAAE;UAAEC,YAAY,EAAER;QAAU,CAAC;MAC1D;MAGA,MAAMS,WAAW,GAAGd,IAAI,CAACS,EAAE,CAACM,KAAK,CAAC,GAAG,CAAC;MACtC,MAAMC,GAAG,GAAGC,QAAQ,CAACH,WAAW,CAAC,CAAC,CAAC,CAAC;MACpC,MAAMI,GAAG,GAAGD,QAAQ,CAACH,WAAW,CAAC,CAAC,CAAC,CAAC;;MAEpC;MACA;MACA,IAAId,IAAI,CAACS,EAAE,KAAKjB,KAAK,CAACiB,EAAE,EAAE;QACxB;QACA;QACAJ,SAAS,CAACM,IAAI,CAACX,IAAI,CAACS,EAAE,CAAC;MACzB;;MAEA;MACA,IAAIU,YAAY;MAChB,IAAIzB,IAAI,CAACsB,GAAG,GAAG,CAAC,CAAC,IAAItB,IAAI,CAACsB,GAAG,GAAG,CAAC,CAAC,CAACE,GAAG,CAAC,EAAE;QACvCC,YAAY,GAAI,GAAE,CAACH,GAAG,GAAG,CAAC,EAAEI,QAAQ,EAAG,IAAGF,GAAG,CAACE,QAAQ,EAAG,EAAC;QACxD,IAAI7B,KAAK,CAAC4B,YAAY,CAAC,CAACE,MAAM,KAAK,OAAO,IAAI,CAAC9B,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,EAAE;UACtEI,KAAK,CAACK,IAAI,CAACpB,KAAK,CAAC4B,YAAY,CAAC,CAAC;UAC/B5B,KAAK,CAAC4B,YAAY,CAAC,CAAChB,MAAM,GAAGH,IAAI;UACjCT,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,GAAG,IAAI;QACxC;MACJ;MACA,IAAIR,IAAI,CAAC,CAAC,CAAC,CAACwB,GAAG,GAAG,CAAC,CAAC,IAAIxB,IAAI,CAACsB,GAAG,CAAC,CAACE,GAAG,GAAG,CAAC,CAAC,EAAE;QAC1CC,YAAY,GAAI,GAAEH,GAAG,CAACI,QAAQ,EAAG,IAAG,CAACF,GAAG,GAAG,CAAC,EAAEE,QAAQ,EAAG,EAAC;QACxD,IAAI7B,KAAK,CAAC4B,YAAY,CAAC,CAACE,MAAM,KAAK,OAAO,IAAI,CAAC9B,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,EAAE;UACtEI,KAAK,CAACK,IAAI,CAACpB,KAAK,CAAC4B,YAAY,CAAC,CAAC;UAC/B5B,KAAK,CAAC4B,YAAY,CAAC,CAAChB,MAAM,GAAGH,IAAI;UACjCT,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,GAAG,IAAI;QACxC;MACJ;MACA,IAAIR,IAAI,CAACsB,GAAG,GAAG,CAAC,CAAC,IAAItB,IAAI,CAACsB,GAAG,GAAG,CAAC,CAAC,CAACE,GAAG,CAAC,EAAE;QACvCC,YAAY,GAAI,GAAE,CAACH,GAAG,GAAG,CAAC,EAAEI,QAAQ,EAAG,IAAGF,GAAG,CAACE,QAAQ,EAAG,EAAC;QACxD,IAAI7B,KAAK,CAAC4B,YAAY,CAAC,CAACE,MAAM,KAAK,OAAO,IAAI,CAAC9B,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,EAAE;UACtEI,KAAK,CAACK,IAAI,CAACpB,KAAK,CAAC4B,YAAY,CAAC,CAAC;UAC/B5B,KAAK,CAAC4B,YAAY,CAAC,CAAChB,MAAM,GAAGH,IAAI;UACjCT,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,GAAG,IAAI;QACxC;MACJ;MACA,IAAIR,IAAI,CAAC,CAAC,CAAC,CAACwB,GAAG,GAAG,CAAC,CAAC,IAAIxB,IAAI,CAACsB,GAAG,CAAC,CAACE,GAAG,GAAG,CAAC,CAAC,EAAE;QAC1CC,YAAY,GAAI,GAAEH,GAAG,CAACI,QAAQ,EAAG,IAAG,CAACF,GAAG,GAAG,CAAC,EAAEE,QAAQ,EAAG,EAAC;QACxD,IAAI7B,KAAK,CAAC4B,YAAY,CAAC,CAACE,MAAM,KAAK,OAAO,IAAI,CAAC9B,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,EAAE;UACtEI,KAAK,CAACK,IAAI,CAACpB,KAAK,CAAC4B,YAAY,CAAC,CAAC;UAC/B5B,KAAK,CAAC4B,YAAY,CAAC,CAAChB,MAAM,GAAGH,IAAI;UACjCT,KAAK,CAAC4B,YAAY,CAAC,CAACjB,OAAO,GAAG,IAAI;QACxC;MACJ;IACF;EACF;AACF;AAEA,eAAeb,GAAG"},"metadata":{},"sourceType":"module","externalDependencies":[]}